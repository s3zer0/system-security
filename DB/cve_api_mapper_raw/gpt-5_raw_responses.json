[
    {
        "library": "PyYAML",
        "version": "5.3.1",
        "response": "{\n  \"CVE-2020-14343\": {\n    \"apis\": [\n      \"full_load\",\n      \"full_load_all\",\n      \"load\",\n      \"load_all\"\n    ],\n    \"reason\": \"The phrase 'arbitrary code execution when it processes untrusted YAML files through the full_load method or with the FullLoader loader' directly implicates full_load and any use of load/load_all with FullLoader. full_load_all also uses FullLoader to process multiple documents, so it inherits the same risk. The attack abuses the 'python/object/new constructor', which FullLoader permitted before 5.4.\"\n  }\n}"
    },
    {
        "library": "setuptools",
        "version": "58.1.0",
        "response": "{\n  \"CVE-2022-40897\": {\n    \"apis\": [],\n    \"reason\": \"The CVE targets \\\"Regular Expression Denial of Service (ReDoS) in package_index.py\\\" triggered by \\\"HTML in a crafted package or custom PackageIndex page.\\\" The listed APIs (distutils shim/override helpers) are unrelated to package_index parsing, networking, or regex handling, so none directly relate.\"\n  },\n  \"CVE-2024-6345\": {\n    \"apis\": [],\n    \"reason\": \"This issue is \\\"in the package_index module\\\" and involves RCE \\\"via its download functions\\\" that handle \\\"URLs provided by users\\\" and can \\\"execute arbitrary commands.\\\" The provided APIs are distutils shim controls, not package_index download functions, so no direct linkage exists.\"\n  },\n  \"CVE-2025-47273\": {\n    \"apis\": [],\n    \"reason\": \"The vulnerability is a \\\"path traversal\\\" in \\\"PackageIndex\\\" that allows writing files \\\"to arbitrary locations on the filesystem.\\\" The target APIs are only for distutils shim/override (e.g., add/remove shim, ensure_local_distutils) and do not participate in PackageIndex file download/write paths.\"\n  }\n}"
    },
    {
        "library": "Werkzeug",
        "version": "2.0.2",
        "response": "{\n  \"CVE-2023-25577\": {\n    \"apis\": [\n      \"formparser.parse_form_data\",\n      \"formparser.parse_multipart_headers\",\n      \"formparser.get_input_stream\",\n      \"formparser.default_stream_factory\"\n    ],\n    \"reason\": \"The phrase 'multipart form data parser will parse an unlimited number of parts' maps to the multipart handling implemented by formparser.parse_form_data, which iterates and parses all parts. Per-part header parsing is handled by formparser.parse_multipart_headers. The phrase 'endpoint that accesses request.data, request.form, request.files, or request.get_data(parse_form_data=False)' implies the request body is fed into the parser via formparser.get_input_stream, while file parts and memory usage are influenced by formparser.default_stream_factory, contributing to the described CPU/RAM/resource exhaustion when 'crafted multipart data' is sent.\"\n  },\n  \"CVE-2024-34069\": {\n    \"apis\": [\n      \"debug.get_pin_and_cookie_name\",\n      \"debug.hash_pin\",\n      \"debug.render_console_html\",\n      \"debug.get_current_traceback\"\n    ],\n    \"reason\": \"The phrases 'The debugger ... can allow an attacker to execute code' and 'enter the debugger PIN' indicate involvement of PIN handling via debug.get_pin_and_cookie_name and debug.hash_pin. Accessing 'the debugger even if it is only running on localhost' refers to the interactive debugger UI and console, which are served via debug.render_console_html and driven by traceback data from debug.get_current_traceback.\"\n  },\n  \"CVE-2023-46136\": {\n    \"apis\": [\n      \"formparser.parse_form_data\",\n      \"formparser.parse_multipart_headers\",\n      \"formparser.get_input_stream\"\n    ],\n    \"reason\": \"The phrase 'upload of a file that starts with CR or LF ... appended chunk by chunk ... lookup for boundary is performed on growing buffer' describes a flaw in multipart parsing. formparser.parse_form_data orchestrates multipart/form-data parsing and boundary scanning, formparser.parse_multipart_headers processes per-part headers, and the vulnerable byte stream is consumed through formparser.get_input_stream, enabling the described denial of service when 'crafted multipart data' is sent.\"\n  },\n  \"CVE-2024-49766\": {\n    \"apis\": [\n      \"utils.safe_join\",\n      \"security.safe_join\",\n      \"middleware.shared_data.safe_join\"\n    ],\n    \"reason\": \"The phrases 'Werkzeug's safe_join() relies on this check' and 'can produce a path that is not safe' due to 'UNC paths like //server/share' directly implicate the safe_join implementations. utils.safe_join, security.safe_join, and middleware.shared_data.safe_join are the safe path-joining APIs that can incorrectly permit unsafe paths on 'Python < 3.11 on Windows'.\"\n  },\n  \"CVE-2024-49767\": {\n    \"apis\": [\n      \"formparser.parse_form_data\",\n      \"formparser.default_stream_factory\",\n      \"formparser.get_input_stream\"\n    ],\n    \"reason\": \"The phrases 'Applications using werkzeug.formparser.MultiPartParser' to 'parse multipart/form-data requests' and 'allocate and block 3 to 8 times the upload size in main memory' indicate the multipart parsing pipeline handled by formparser.parse_form_data, with memory allocation behavior influenced by formparser.default_stream_factory for file parts, and data ingestion via formparser.get_input_stream that enables the excessive buffering.\"\n  },\n  \"CVE-2023-23934\": {\n    \"apis\": [\n      \"http.parse_cookie\"\n    ],\n    \"reason\": \"The phrase 'Browsers may allow \\\"nameless\\\" cookies that look like =value' and 'Werkzeug prior to 2.2.3 will parse the cookie `=__Host-test=bad` as `__Host-test=bad`' directly implicate the cookie parsing routine http.parse_cookie, which misinterprets nameless cookies and exposes the application to the described issue.\"\n  }\n}"
    }
]