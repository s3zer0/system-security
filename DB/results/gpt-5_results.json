{
    "PyYAML": {
        "5.3.1": {
            "cves": [
                "CVE-2020-14343"
            ],
            "mapping_result": {
                "CVE-2020-14343": {
                    "apis": [
                        "full_load",
                        "full_load_all",
                        "load",
                        "load_all"
                    ],
                    "reason": "The phrase 'susceptible to arbitrary code execution when it processes untrusted YAML files through the full_load method or with the FullLoader loader' explicitly identifies full_load and implies that using load or load_all 'with the FullLoader loader' is affected. The statement that an attacker can abuse 'the python/object/new constructor' points to dangerous object instantiation during deserialization performed by these FullLoader-based APIs, which also includes the multi-document variant full_load_all."
                }
            }
        }
    },
    "setuptools": {
        "58.1.0": {
            "cves": [
                "CVE-2022-40897",
                "CVE-2024-6345",
                "CVE-2025-47273"
            ],
            "mapping_result": {
                "CVE-2022-40897": {
                    "apis": [
                        "package_index.distros_for_url",
                        "package_index.interpret_distro_name",
                        "package_index.parse_bdist_wininst"
                    ],
                    "reason": "The phrase 'Regular Expression Denial of Service (ReDoS) in package_index.py' and reference to 'HTML in a crafted package or custom PackageIndex page' indicate the vulnerability lies in regex-based parsing of links and distribution names from index pages. The APIs package_index.distros_for_url, package_index.interpret_distro_name, and package_index.parse_bdist_wininst process URLs/names extracted from index HTML and rely on regex matching, making them directly implicated in the ReDoS described."
                },
                "CVE-2024-6345": {
                    "apis": [
                        "installer.fetch_build_egg"
                    ],
                    "reason": "The CVE states 'a vulnerability in the package_index module ... download functions' that are 'used to download packages from URLs provided by users' and are 'susceptible to code injection.' The API installer.fetch_build_egg triggers package downloads based on provided URLs via PackageIndex internals, making it directly involved when user-controlled URLs are supplied and thus relevant to the described code injection risk."
                },
                "CVE-2025-47273": {
                    "apis": [
                        "archive_util.unpack_archive",
                        "archive_util.unpack_tarfile",
                        "archive_util.unpack_zipfile",
                        "wheel.unpack"
                    ],
                    "reason": "The CVE highlights a 'path traversal vulnerability in PackageIndex' that would 'write files to arbitrary locations on the filesystem.' During handling of downloaded distributions, setuptools extracts archives; the APIs archive_util.unpack_archive, archive_util.unpack_tarfile, archive_util.unpack_zipfile, and wheel.unpack perform file extraction and can write paths contained in archives. These extraction routines are the file-writing mechanisms strongly implied by the CVE’s description of arbitrary file writes."
                }
            }
        }
    },
    "Werkzeug": {
        "2.0.2": {
            "cves": [
                "CVE-2023-25577",
                "CVE-2024-34069",
                "CVE-2023-46136",
                "CVE-2024-49766",
                "CVE-2024-49767",
                "CVE-2023-23934"
            ],
            "mapping_result": {
                "CVE-2023-25577": {
                    "apis": [
                        "formparser.parse_form_data",
                        "formparser.parse_multipart_headers",
                        "formparser.get_input_stream",
                        "formparser.default_stream_factory",
                        "formparser.parse_options_header"
                    ],
                    "reason": "The phrase 'multipart form data parser will parse an unlimited number of parts, including file parts' and references to 'request.data, request.form, request.files' indicate the multipart parser path. parse_form_data invokes the multipart parser, parse_multipart_headers and parse_options_header process part and boundary metadata, get_input_stream reads the request body for parts, and default_stream_factory creates per-part file streams that can consume 'memory and file handles'."
                },
                "CVE-2024-34069": {
                    "apis": [
                        "debug.get_pin_and_cookie_name",
                        "debug.hash_pin",
                        "debug.get_machine_id",
                        "debug.render_console_html"
                    ],
                    "reason": "The phrases 'The debugger ... can allow an attacker to execute code' and 'enter the debugger PIN' and 'allows access to the debugger even if it is only running on localhost' point to the debugger’s PIN authentication and console. get_pin_and_cookie_name and get_machine_id generate and identify the PIN, hash_pin validates it, and render_console_html serves the interactive debugger console that would be exposed."
                },
                "CVE-2023-46136": {
                    "apis": [
                        "formparser.parse_form_data",
                        "formparser.parse_multipart_headers",
                        "formparser.get_input_stream",
                        "formparser.default_stream_factory",
                        "formparser.parse_options_header"
                    ],
                    "reason": "The phrases 'upload of a file that starts with CR or LF' and 'lookup for boundary is performed on growing buffer' describe a flaw in multipart/form-data parsing. parse_form_data triggers multipart parsing, parse_multipart_headers and parse_options_header handle the part headers and boundary, get_input_stream feeds chunks into the growing buffer, and default_stream_factory manages file part storage contributing to the 'denial of service by sending crafted multipart data'."
                },
                "CVE-2024-49766": {
                    "apis": [
                        "utils.safe_join",
                        "security.safe_join",
                        "middleware.shared_data.safe_join"
                    ],
                    "reason": "The phrases 'Werkzeug's safe_join() relies on this check' and 'os.path.isabs() does not catch UNC paths like //server/share' and 'produce a path that is not safe' directly implicate the safe_join path-joining helpers. utils.safe_join, security.safe_join, and middleware.shared_data.safe_join implement that path normalization and are affected on Windows < 3.11."
                },
                "CVE-2024-49767": {
                    "apis": [
                        "formparser.parse_form_data",
                        "formparser.parse_multipart_headers",
                        "formparser.get_input_stream",
                        "formparser.default_stream_factory",
                        "formparser.parse_options_header"
                    ],
                    "reason": "The phrases 'Applications using werkzeug.formparser.MultiPartParser' and 'multipart/form-data' and 'allocate and block 3 to 8 times the upload size in main memory' identify the multipart form parser pipeline. parse_form_data uses MultiPartParser, parse_multipart_headers and parse_options_header process boundaries and parts, get_input_stream reads the upload stream, and default_stream_factory materializes part content, all contributing to the excessive allocation."
                },
                "CVE-2023-23934": {
                    "apis": [
                        "http.parse_cookie",
                        "sansio.request.parse_cookie"
                    ],
                    "reason": "The phrases 'Browsers may allow \"nameless\" cookies that look like =value' and 'Werkzeug prior to 2.2.3 will parse the cookie \"=__Host-test=bad\" as \"__Host-test=bad\"' point to the cookie parsing logic. http.parse_cookie implements cookie parsing and sansio.request.parse_cookie exposes the same parsing for requests, causing the misinterpretation of nameless cookies."
                }
            }
        }
    }
}