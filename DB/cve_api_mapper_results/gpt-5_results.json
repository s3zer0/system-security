{
    "setuptools": {
        "58.1.0": {
            "cves": [
                "CVE-2022-40897",
                "CVE-2024-6345",
                "CVE-2025-47273"
            ],
            "mapping_result": {
                "CVE-2022-40897": {
                    "apis": [],
                    "reason": "The issue is a \"Regular Expression Denial of Service (ReDoS) in package_index.py\" triggered by \"HTML in a crafted package or custom PackageIndex page\". All provided APIs (add_shim, clear_distutils, do_override, enabled, ensure_local_distutils, remove_shim, warn_distutils_present) are distutils shim utilities and are not involved in package_index HTML parsing or regex processing."
                },
                "CVE-2024-6345": {
                    "apis": [],
                    "reason": "This CVE targets a \"vulnerability in the package_index module\" where its \"download functions\" can \"execute arbitrary commands\" via user-controlled URLs. The listed APIs only manage distutils shimming and do not perform package downloads or command execution, so none are directly related."
                },
                "CVE-2025-47273": {
                    "apis": [],
                    "reason": "The flaw is a \"path traversal vulnerability in PackageIndex\" allowing writes \"to arbitrary locations on the filesystem\". The provided APIs are distutils shim helpers and are unrelated to PackageIndex file path handling or writes."
                }
            }
        }
    },
    "PyYAML": {
        "5.3.1": {
            "cves": [
                "CVE-2020-14343"
            ],
            "mapping_result": {
                "CVE-2020-14343": {
                    "apis": [
                        "full_load",
                        "full_load_all",
                        "load",
                        "load_all"
                    ],
                    "reason": "The phrase 'processes untrusted YAML files through the full_load method or with the FullLoader loader' directly implicates full_load, and strongly implies full_load_all since it uses the same FullLoader for multiple documents. It also covers load and load_all when used 'with the FullLoader loader.' These APIs can deserialize tags like 'python/object/new', and the CVE states this flaw 'allows an attacker to execute arbitrary code ... by abusing the python/object/new constructor.'"
                }
            }
        }
    },
    "Werkzeug": {
        "2.0.2": {
            "cves": [
                "CVE-2023-25577",
                "CVE-2024-34069",
                "CVE-2023-46136",
                "CVE-2024-49766",
                "CVE-2024-49767",
                "CVE-2023-23934"
            ],
            "mapping_result": {
                "CVE-2023-25577": {
                    "apis": [
                        "formparser.parse_form_data",
                        "formparser.default_stream_factory",
                        "formparser.get_input_stream",
                        "wrappers.request.default_stream_factory",
                        "wrappers.request.get_input_stream"
                    ],
                    "reason": "The phrase 'multipart form data parser will parse an unlimited number of parts' directly implicates formparser.parse_form_data, which drives MultiPartParser over each part. Accessing 'request.form' / 'request.files' is handled through the request layer that reads the body ('request.get_data(...)'), which uses wrappers.request.get_input_stream/formparser.get_input_stream and allocates per-part streams via 'default_stream_factory'. The phrase 'Unlimited file parts can use up memory and file handles' explains why the stream factories (formparser.default_stream_factory, wrappers.request.default_stream_factory) are part of the resource exhaustion path."
                },
                "CVE-2024-34069": {
                    "apis": [
                        "debug.get_pin_and_cookie_name",
                        "debug.hash_pin",
                        "debug.get_machine_id"
                    ],
                    "reason": "The phrases 'The debugger ... can allow an attacker to execute code' and 'enter the debugger PIN' map to the debugger's PIN mechanism: debug.get_pin_and_cookie_name determines the PIN and cookie names, debug.hash_pin handles PIN hashing/verification, and debug.get_machine_id contributes entropy to the PIN. These components control access 'even if it is only running on localhost'."
                },
                "CVE-2023-46136": {
                    "apis": [
                        "formparser.parse_form_data",
                        "formparser.get_input_stream",
                        "wrappers.request.get_input_stream"
                    ],
                    "reason": "The phrase 'upload of a file that starts with CR or LF ... appended chunk by chunk into internal bytearray and lookup for boundary is performed on growing buffer' describes multipart streaming and boundary scanning performed by the multipart parser invoked via formparser.parse_form_data reading from the request body. The input body is obtained through formparser.get_input_stream and wrappers.request.get_input_stream, whose chunked reads trigger the vulnerable growing-buffer search leading to denial of service."
                },
                "CVE-2024-49766": {
                    "apis": [
                        "utils.safe_join",
                        "security.safe_join",
                        "middleware.shared_data.safe_join"
                    ],
                    "reason": "The phrase 'Werkzeug's safe_join() relies on this check, and so can produce a path that is not safe' directly targets the safe_join path resolution helpers. utils.safe_join is the core helper, while security.safe_join and middleware.shared_data.safe_join use the same logic; on 'Python < 3.11 on Windows' they can accept UNC paths like '//server/share', leading to unintended access."
                },
                "CVE-2024-49767": {
                    "apis": [
                        "formparser.parse_form_data"
                    ],
                    "reason": "The phrase 'Applications using werkzeug.formparser.MultiPartParser ... to parse multipart/form-data ... can cause the parser to allocate and block 3 to 8 times the upload size in main memory' directly implicates the multipart parsing entry point formparser.parse_form_data, which invokes MultiPartParser for 'multipart/form-data' requests and triggers the excessive allocation."
                },
                "CVE-2023-23934": {
                    "apis": [
                        "http.parse_cookie",
                        "sansio.request.parse_cookie"
                    ],
                    "reason": "The phrase 'Browsers may allow \"nameless\" cookies that look like \"=value\" ... Werkzeug prior to 2.2.3 will parse the cookie \"=__Host-test=bad\" as \"__Host-test=bad\"' identifies the cookie parsing logic. Incoming Cookie headers are parsed by http.parse_cookie and, in the sansio layer, sansio.request.parse_cookie, which exhibit the incorrect handling of nameless cookies."
                }
            }
        }
    }
}