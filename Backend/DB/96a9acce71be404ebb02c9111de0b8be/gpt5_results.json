{
    "PyYAML": {
        "5.3.1": {
            "cves": [
                "CVE-2020-14343"
            ],
            "mapping_result": {
                "CVE-2020-14343": {
                    "apis": [
                        "full_load",
                        "load",
                        "load_all",
                        "full_load_all"
                    ],
                    "reason": "The phrase 'arbitrary code execution when it processes untrusted YAML files through the full_load method or with the FullLoader loader' explicitly names full_load. The reference to 'the FullLoader loader' strongly implies load and load_all when invoked with Loader=FullLoader, and the multi-document convenience full_load_all, since they use the same FullLoader behavior. These code paths can be exploited by 'abusing the python/object/new constructor' during deserialization."
                }
            }
        }
    },
    "Werkzeug": {
        "2.0.2": {
            "cves": [
                "CVE-2023-25577",
                "CVE-2024-34069",
                "CVE-2023-46136",
                "CVE-2024-49766",
                "CVE-2024-49767",
                "CVE-2023-23934"
            ],
            "mapping_result": {
                "CVE-2023-25577": {
                    "apis": [
                        "formparser.parse_form_data",
                        "formparser.parse_multipart_headers",
                        "formparser.default_stream_factory",
                        "formparser.get_input_stream"
                    ],
                    "reason": "The phrase 'multipart form data parser will parse an unlimited number of parts' maps directly to the multipart parser entry points. parse_form_data triggers multipart parsing, parse_multipart_headers processes each part, default_stream_factory handles file parts, and get_input_stream provides the stream the parser reads from, enabling the excessive part parsing that leads to 'unexpectedly high resource usage' and denial of service."
                },
                "CVE-2024-34069": {
                    "apis": [
                        "debug.get_pin_and_cookie_name",
                        "debug.hash_pin",
                        "debug.tbtools.get_current_traceback",
                        "debug.tbtools.render_console_html"
                    ],
                    "reason": "The phrases 'The debugger ... can allow an attacker to execute code' and 'enter the debugger PIN' indicate the vulnerability is in the interactive debugger and its PIN mechanism. get_pin_and_cookie_name and hash_pin implement the PIN logic the attacker relies on, while tbtools.get_current_traceback and tbtools.render_console_html provide the debugger UI that, once accessed, enables code execution 'even if it is only running on localhost'."
                },
                "CVE-2023-46136": {
                    "apis": [
                        "formparser.parse_form_data",
                        "formparser.get_input_stream",
                        "formparser.exhaust_stream"
                    ],
                    "reason": "The phrase 'upload of a file that starts with CR or LF ... lookup for boundary is performed on growing buffer' describes a flaw in multipart body parsing. parse_form_data is the multipart parser entry point, get_input_stream supplies the raw request stream being parsed chunk by chunk, and exhaust_stream drives consumption of the stream, enabling the CPU-heavy boundary search that causes the described denial of service."
                },
                "CVE-2024-49766": {
                    "apis": [
                        "utils.safe_join",
                        "security.safe_join",
                        "middleware.shared_data.safe_join",
                        "utils.send_from_directory"
                    ],
                    "reason": "The phrase 'Werkzeug's safe_join() relies on this check, and so can produce a path that is not safe' points directly to the safe_join implementations. utils.safe_join, security.safe_join, and middleware.shared_data.safe_join are the path-joining helpers affected on Windows < 3.11. utils.send_from_directory relies on safe_join to constrain filesystem access, so it can also 'allow unintended access to data' when safe_join is bypassed."
                },
                "CVE-2024-49767": {
                    "apis": [
                        "formparser.parse_form_data",
                        "formparser.default_stream_factory",
                        "formparser.get_input_stream"
                    ],
                    "reason": "The phrase 'Applications using werkzeug.formparser.MultiPartParser ... to parse multipart/form-data ... can cause the parser to allocate and block 3 to 8 times the upload size in main memory' implicates the multipart parsing path. parse_form_data invokes MultiPartParser, default_stream_factory governs in-memory/file buffering of parts that contributes to memory growth, and get_input_stream feeds the parser with the uploaded data that triggers the excessive allocation."
                },
                "CVE-2023-23934": {
                    "apis": [
                        "http.parse_cookie",
                        "sansio.request.parse_cookie"
                    ],
                    "reason": "The phrase 'Werkzeug prior to 2.2.3 will parse the cookie \"=__Host-test=bad\" as \"__Host-test=bad\"' identifies a bug in cookie parsing. http.parse_cookie is the core cookie parser used by Werkzeug, and sansio.request.parse_cookie exposes the same parsing behavior, leading to the incorrect handling of 'nameless' cookies from a 'vulnerable browser'."
                }
            }
        }
    }
}