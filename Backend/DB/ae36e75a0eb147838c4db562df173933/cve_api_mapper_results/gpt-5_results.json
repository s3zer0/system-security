{
    "setuptools": {
        "58.1.0": {
            "cves": [
                "CVE-2022-40897",
                "CVE-2024-6345",
                "CVE-2025-47273"
            ],
            "mapping_result": {
                "CVE-2022-40897": {
                    "apis": [],
                    "reason": "The phrase 'Regular Expression Denial of Service (ReDoS) in package_index.py' shows the issue is in package_index HTML parsing/regex handling. The available APIs (e.g., 'add_shim', 'clear_distutils', 'do_override', 'enabled', 'ensure_local_distutils', 'remove_shim', 'warn_distutils_present') are distutils shim/override helpers and are not involved in package_index processing."
                },
                "CVE-2024-6345": {
                    "apis": [],
                    "reason": "The phrase 'vulnerability in the package_index module ... allows for remote code execution via its download functions' indicates the flaw is in package_index download/URL handling. None of the listed APIs relate to 'download functions' or 'package URLs'; they are distutils shim utilities."
                },
                "CVE-2025-47273": {
                    "apis": [],
                    "reason": "The phrase 'A path traversal vulnerability in PackageIndex ... allowed to write files to arbitrary locations' points to file write paths within PackageIndex. The provided APIs are distutils shimming ('add_shim', 'do_override', etc.) and are not responsible for PackageIndex file writing."
                }
            }
        }
    },
    "PyYAML": {
        "5.3.1": {
            "cves": [
                "CVE-2020-14343"
            ],
            "mapping_result": {
                "CVE-2020-14343": {
                    "apis": [
                        "full_load",
                        "full_load_all",
                        "load",
                        "load_all"
                    ],
                    "reason": "The CVE states the issue occurs when PyYAML \"processes untrusted YAML files through the full_load method or with the FullLoader loader.\" This directly implicates full_load, and by strong implication its multi-document counterpart full_load_all which uses the same FullLoader semantics. It also affects load and load_all when they are called \"with the FullLoader loader,\" allowing the \"python/object/new constructor\" to be processed and enabling arbitrary code execution."
                }
            }
        }
    },
    "Werkzeug": {
        "2.0.2": {
            "cves": [
                "CVE-2023-25577",
                "CVE-2024-34069",
                "CVE-2023-46136",
                "CVE-2024-49766",
                "CVE-2024-49767",
                "CVE-2023-23934"
            ],
            "mapping_result": {
                "CVE-2023-25577": {
                    "apis": [
                        "formparser.parse_form_data",
                        "formparser.parse_multipart_headers",
                        "formparser.get_input_stream",
                        "formparser.exhaust_stream"
                    ],
                    "reason": "The phrase \"multipart form data parser will parse an unlimited number of parts\" and references to parsing when accessing \"request.data\", \"request.form\", or \"request.files\" point directly to the multipart parsing implemented by formparser.parse_form_data and its helpers formparser.parse_multipart_headers, formparser.get_input_stream, and formparser.exhaust_stream, which iterate over and read each part and thus can cause the described resource exhaustion."
                },
                "CVE-2024-34069": {
                    "apis": [
                        "debug.get_pin_and_cookie_name",
                        "debug.hash_pin",
                        "debug.get_machine_id"
                    ],
                    "reason": "The description mentions \"The debugger ... enter the debugger PIN\" and that this \"allows access to the debugger\". The PIN generation and validation logic is handled by debug.get_pin_and_cookie_name, debug.hash_pin, and debug.get_machine_id, which control the debugger's authentication and cookie, making them directly related to the vulnerable debugger access."
                },
                "CVE-2023-46136": {
                    "apis": [
                        "formparser.parse_form_data",
                        "formparser.parse_multipart_headers",
                        "formparser.get_input_stream",
                        "formparser.exhaust_stream"
                    ],
                    "reason": "The issue occurs when an \"upload of a file that starts with CR or LF\" causes boundary lookup on a growing buffer during \"multipart data\" parsing. This behavior is in the multipart parsing path used by formparser.parse_form_data and its helpers formparser.parse_multipart_headers, formparser.get_input_stream, and formparser.exhaust_stream, which read and process multipart body parts."
                },
                "CVE-2024-49766": {
                    "apis": [
                        "utils.safe_join",
                        "middleware.shared_data.safe_join"
                    ],
                    "reason": "The report states \"Werkzeug's safe_join() relies on\" os.path.isabs() and \"can produce a path that is not safe\" on Windows, potentially allowing unintended access. The path-joining helpers utils.safe_join and middleware.shared_data.safe_join implement this logic and are therefore directly related."
                },
                "CVE-2024-49767": {
                    "apis": [
                        "formparser.parse_form_data",
                        "formparser.parse_multipart_headers",
                        "formparser.get_input_stream",
                        "formparser.exhaust_stream"
                    ],
                    "reason": "It specifies \"Applications using werkzeug.formparser.MultiPartParser ... to parse multipart/form-data\" can cause the parser to allocate excessive memory. The multipart parsing entry point and helpers are formparser.parse_form_data, formparser.parse_multipart_headers, formparser.get_input_stream, and formparser.exhaust_stream, which handle reading and processing multipart uploads."
                },
                "CVE-2023-23934": {
                    "apis": [
                        "http.parse_cookie",
                        "sansio.request.parse_cookie"
                    ],
                    "reason": "The description says browsers may allow \"nameless\" cookies and that Werkzeug \"will parse the cookie '=__Host-test=bad' as '__Host-test=bad'\". Cookie parsing is performed by http.parse_cookie and exposed via sansio.request.parse_cookie, which would accept and misinterpret such nameless cookies."
                }
            }
        }
    }
}