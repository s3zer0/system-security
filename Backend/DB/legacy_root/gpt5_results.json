{
    "setuptools": {
        "58.1.0": {
            "cves": [
                "CVE-2022-40897",
                "CVE-2024-6345",
                "CVE-2025-47273"
            ],
            "mapping_result": {
                "CVE-2022-40897": {
                    "apis": [],
                    "reason": "The phrases \"Regular Expression Denial of Service (ReDoS) in package_index.py\" and \"via HTML in a crafted package or custom PackageIndex page\" show the flaw is in package_index HTML parsing/regex. The listed APIs (add_shim, clear_distutils, do_override, enabled, ensure_local_distutils, remove_shim, warn_distutils_present) are distutils shim/override utilities, not package_index parsing code, so none apply."
                },
                "CVE-2024-6345": {
                    "apis": [],
                    "reason": "The phrases \"vulnerability in the package_index module\" and \"download functions ... download packages from URLs ... can execute arbitrary commands\" indicate the issue is in package_index download helpers. None of the listed APIs implement download or URL handling; they are distutils shim/override utilities, so none apply."
                },
                "CVE-2025-47273": {
                    "apis": [],
                    "reason": "The phrases \"path traversal vulnerability in PackageIndex\" and \"write files to arbitrary locations on the filesystem\" show the issue is in PackageIndex file write paths. The provided APIs are distutils shim/override controls and do not perform package downloads or file writes; therefore, none are related."
                }
            }
        }
    },
    "PyYAML": {
        "5.3.1": {
            "cves": [
                "CVE-2020-14343"
            ],
            "mapping_result": {
                "CVE-2020-14343": {
                    "apis": [
                        "full_load",
                        "full_load_all",
                        "load",
                        "load_all"
                    ],
                    "reason": "The description states the library is \"susceptible to arbitrary code execution ... through the full_load method or with the FullLoader loader.\" This directly implicates full_load, and by extension full_load_all which uses the same FullLoader for multi-document input. It also implies load and load_all are affected when called \"with the FullLoader loader\". The attack abuses \"the python/object/new constructor,\" which these loader-based APIs process, enabling arbitrary object construction during deserialization."
                }
            }
        }
    },
    "Werkzeug": {
        "2.0.2": {
            "cves": [
                "CVE-2023-25577",
                "CVE-2024-34069",
                "CVE-2023-46136",
                "CVE-2024-49766",
                "CVE-2024-49767",
                "CVE-2023-23934"
            ],
            "mapping_result": {
                "CVE-2023-25577": {
                    "apis": [
                        "formparser.parse_form_data",
                        "formparser.parse_multipart_headers",
                        "formparser.default_stream_factory"
                    ],
                    "reason": "The phrase \"multipart form data parser will parse an unlimited number of parts, including file parts\" directly implicates the multipart parser entry point and per-part header parsing, i.e., formparser.parse_form_data and formparser.parse_multipart_headers. The phrase \"Unlimited file parts can use up memory and file handles\" relates to how file parts are materialized, which is handled by formparser.default_stream_factory for each part."
                },
                "CVE-2024-34069": {
                    "apis": [
                        "debug.get_pin_and_cookie_name",
                        "debug.hash_pin",
                        "debug.get_machine_id"
                    ],
                    "reason": "The phrases \"The debugger ... can allow an attacker to execute code\" and \"enter the debugger PIN\" indicate the issue centers on the debugger's PIN-based access control. The PIN and its cookie are produced and validated via debug.get_pin_and_cookie_name, debug.hash_pin, and debug.get_machine_id."
                },
                "CVE-2023-46136": {
                    "apis": [
                        "formparser.parse_form_data"
                    ],
                    "reason": "The phrase \"upload of a file that starts with CR or LF ... lookup for boundary is performed on growing buffer\" describes a flaw in the multipart form-data parsing algorithm. That parsing is performed by formparser.parse_form_data."
                },
                "CVE-2024-49766": {
                    "apis": [
                        "utils.safe_join",
                        "security.safe_join",
                        "middleware.shared_data.safe_join"
                    ],
                    "reason": "The phrases \"Werkzeug's safe_join() relies on this check\" and \"can produce a path that is not safe\" identify the vulnerable path-joining helper. The safe_join helpers appear in utils.safe_join, security.safe_join, and are also used by static file serving in middleware.shared_data.safe_join."
                },
                "CVE-2024-49767": {
                    "apis": [
                        "formparser.parse_form_data",
                        "formparser.default_stream_factory"
                    ],
                    "reason": "The phrases \"Applications using werkzeug.formparser.MultiPartParser ... to parse multipart/form-data\" and \"allocate and block 3 to 8 times the upload size in main memory\" indicate the multipart parser and its storage behavior are at fault. Parsing is done by formparser.parse_form_data, while memory/file handling per part is controlled by formparser.default_stream_factory."
                },
                "CVE-2023-23934": {
                    "apis": [
                        "http.parse_cookie",
                        "sansio.request.parse_cookie"
                    ],
                    "reason": "The phrases \"Browsers may allow 'nameless' cookies that look like '=value'\" and \"Werkzeug prior to 2.2.3 will parse the cookie '=__Host-test=bad' as '__Host-test=bad'\" point to cookie parsing logic. This is implemented by http.parse_cookie and also exposed via sansio.request.parse_cookie."
                }
            }
        }
    }
}